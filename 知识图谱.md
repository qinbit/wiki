# 知识图谱

## Java基础

### concurrent

#### 锁

##### AQS

###### ReentrantReadWriteLock

###### ReentrantLock

###### CountDownLatch

###### Semphore

##### CAS自旋volatile变量

##### LockSupport

###### park()

###### unpark()

##### 公平锁与非公平锁

### transient

序列化与反序列化会忽略该属性

### 静态内部类和非静态内部类

* 静态内部类只能访问外部类的静态成员和静态方法，非静态内部类既可以访问外部静态变量又可以访问外部非静态变量
* 静态内部类可以直接实例化，非静态内部类需要在外部类实例的基础上进行实例化

### Thread类

#### 状态：new、runnable、running、blocked、waiting、time_waiting、dead

#### 方法：wait()、sleep()、join()、interrupt()

#### 守护线程

### 线程池

#### 参数配置

    1、corePoolSize：核心线程数
        * 核心线程会一直存活，及时没有任务需要执行
        * 当线程数小于核心线程数时，即使有线程空闲，线程池也会优先创建新线程处理
        * 设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭
 
    2、queueCapacity：任务队列容量（阻塞队列）
        * 当核心线程数达到最大时，新任务会放在队列中排队等待执行
 
    3、maxPoolSize：最大线程数
        * 当线程数>=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务
        * 当线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务而抛出异常
 
    4、 keepAliveTime：线程空闲时间
        * 当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize
        * 如果allowCoreThreadTimeout=true，则会直到线程数量=0
 
    5、allowCoreThreadTimeout：允许核心线程超时
    6、rejectedExecutionHandler：任务拒绝处理器
        * 两种情况会拒绝处理任务：
            - 当线程数已经达到maxPoolSize，切队列已满，会拒绝新任务
            - 当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务
        * 线程池会调用rejectedExecutionHandler来处理这个任务。如果没有设置默认是AbortPolicy，会抛出异常
        * ThreadPoolExecutor类有几个内部实现类来处理这类情况：
            - AbortPolicy 丢弃任务，抛运行时异常
            - CallerRunsPolicy 执行任务
            - DiscardPolicy 忽视，什么都不会发生
            - DiscardOldestPolicy 从队列中踢出最先进入队列（最后一个执行）的任务
        * 实现RejectedExecutionHandler接口，可自定义处理器

#### 执行方式

    1. 当线程数小于核心线程数时，创建线程。
    2. 当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。
    3. 当线程数大于等于核心线程数，且任务队列已满
        - 若线程数小于最大线程数，创建线程
        - 若线程数等于最大线程数，抛出异常，拒绝任务

## IO

### 同步、异步、阻塞、非阻塞

### Unix 5种I/O模型

#### 同步阻塞

#### 同步非阻塞

#### IO复用

#### 信号驱动IO

#### 异步IO

## 框架

### Spring Cloud

### Zookeeper

#### 特性

* 顺序一致性
* 原子性
* 单一视图
* 可靠性/持久性
* 实时性（一段时间内）

#### ZAB协议

非通用的分布式一致算法，是特别设计的奔溃可恢复原子广播suan'fa

##### 广播模式

* 仅Leader有写入权限

##### 奔溃恢复模式

###### Leader选举

###### 数据同步

##### 角色

* Leader
* Follower
* Observer
  Observer机器不参与Leader选举过程，也不参与写操作的『过半写成功』策略，因此Observer可以在不影响写性能的情况下提升集群的读性能。

#### 应用

##### 发布-订阅

##### 命名服务

##### 心跳检测

##### 工作进度汇报

##### Master选举

##### 分布式锁

### kafka

#### 使用场景

##### 日志收集

##### 消息系统

##### 流式处理

##### 用户活动追踪

##### 运营指标

## 数据库

### 读写分离

#### 优点

##### 冗余

##### 提升性能

###### 服务器增加，负荷增大

###### 缓解了X锁与S锁的争用

###### 分摊读取

### MySQL

#### 重要参数

* innodb_buffer_pool_size
* innodb_buffer_pool_instances
* innodb_io_capacity
* innodb_flush_log_at_trx_commit
* sync_binlog

## 数据结构与算法

### 红黑树

#### 规则

* 节点非黑即红
* 跟节点为黑色
* 叶子节点（NIL节点）为黑
* 红节点的子节点为黑
* 任一节点到叶子节点的简单路径黑节点数相等


#### 特点

* 从根到叶子的最长路径最多不会超过最短路径的两倍
* 它可以在O(logN)时间内完成查找，插入和删除，这里的N是树中元素的数目
* 红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树

## Java虚拟机

### 内存区域

#### 线程私有

##### 程序计数器

##### 虚拟机栈

##### 本地方法栈

#### 线程共享

##### Java堆

###### 对象内存分配

####### CAS配合失败重试

####### TLAB

###### 对象内存布局

####### 对象头

####### 实例数据

####### 对齐填充

###### 对象的访问

####### 句柄池

####### 直接指针 HotSpot

##### 方法区

#### 直接内存

BIO DirectByteBuffer

### 垃圾回收

#### 垃圾判定

##### 引用计数法

##### 可达性分析法

GCroot:
虚拟机栈中的引用对象
方法区中的静态类属性
方法区中的常量应用
本地方法栈中的JNI引用对象

#### 回收方式

##### 标记-清除算法

##### 复制算法

##### 标记-整理算法

#### 垃圾收集器

##### 新生代收集器

###### Serial收集器

####### 单线程，没有上下文切换开销

####### Stop The World

####### 适合Client模式

###### ParNew收集器

####### Serial多线程版

####### 唯一可以与CMS搭配使用的新生代收集器

###### Parallel Scavenge收集器

####### 吞吐量优先

####### 自适应调节策略

##### 老年代收集器

###### Serial Old收集器

####### 与Parallel Scavenge搭配使用

####### CMS后备预案

###### Parallel Old收集器

####### JDK1.6提供，1.7 1.8默认收集器

###### CMS收集器

####### 特点

######## 最短回收停顿时间

######## 标记-清除算法

####### 过程

######## 初始标记

######## 并发标记

######## 重新标记

######## 并发清除

####### 缺点

######## CPU资源敏感

######## 无法处理浮动垃圾

######## 空间碎片

##### G1收集器

###### 并行与并发

###### 分代收集

###### 空间整合

###### 可预测停顿

### 工具

#### jps

#### jstat

#### jmap

#### jstack

#### JConsole

#### VisualVM

### 虚拟机执行子系统

#### 类文件结构

##### 内容

* 以字节为基础的二进制流，没有分隔符，没有空隙
* 魔术：0xCAFEBABY
* 文件版本：1.7 -> 51，1.8 -> 52
* 常量池：字面量、符号引用（类名、方法名、描述符等）；由类文件utf8_info常量最大长度限制，变量、方法名的最大长度为64KB；
* Code属性：虚拟机规定一个方法不允许超过65535条字节码指令，这限制了一个方法的长度；Javac将this关键字当作方法隐含参数


##### javap

类文件分析工具

##### 字节码指令

* 面向操作数栈而不是寄存器的架构
* 加载存储指令：将数据在栈帧中的局部变量表和操作数栈之间来回传输
* 运算指令：add
* 类型转换指令：i2b
* 对象创建与访问指令：new
* 操作数栈管理指令：pop
* 控制转移指令：ifeq
* 方法调用指令
* 异常处理指令：athrow
* 同步指令：monitorenter


#### 虚拟机类加载机制

##### 类的生命周期

加载 -> 验证 -> 准备 -> 解析 -> 初始化

###### 加载

* 加载二进制流
* 将静态结构转化为方法去运行时的数据结构
* 在内存中生成这个类的Class对象


###### 验证

* Class文件格式验证：魔数、版本
* 元数据验证：Java语言规范
* 字节码校验：对方法体进行校验
* 符号类引用：NoSuchMethodError、NoSuchFieldError等异常此阶段产生

###### 准备

为类变量分配内存并设置初始值

###### 解析

将符号引用替换为直接引用（目标zhi'zhen）

###### 初始化

静态变量赋值和静态块执行

##### 类加载器

###### 双亲委派模型

####### tomcat

* 解决的问题：应用之间隔离、容器与应用隔离、应用类库共享、HotSwap
* 解决办法：Common类加载器、Catalin类加载器、Shared类加载器、WebApp类加载器、Jsp类加载器

###### 破坏双亲委派模型

####### 线程上下文加载器

####### OSGi

### 程序编译与代码优化

#### 编译优化

##### Java语法糖

###### 泛型与泛型擦除

###### 自动拆装箱

#### 运行期优化

JIT：即时编译器

##### 公共子表达式消除

##### 数组边界检查消除

##### 方法内联

### 内存模型

#### 主内存与工作内存

#### 内存间的交互

lock、unlock、read、load、use、assign、store、write


#### 对volatile变量的特殊规则

##### 内存无效化

##### 禁止指令重排

#### 原子性、可见性和有序性

#### 先行发生原则

* 程序次序原则
* volatile变量原则
* 锁原则
* 线程创建原则
* 线程终止检测原则
* 线程中断原则
* 对象终结原则
* 传递原则

### 多线程

#### 线程实现

使用内核线程实现

#### 线程状态

* new
* runnable
* running
* blocked
* waiting
* time_waiting
* dead

#### 线程安全的实现方法

##### 互斥同步

临界区、信号量

##### 非阻塞同步

CAS

#### 锁优化

##### 自旋锁

##### 锁消除

##### 锁粗化

##### 轻量级锁

使用CAS操作，避免了使用互斥量的开销

##### 偏向锁

## redis

### 数据结构

#### String

#### Hash

#### List

#### Set

#### Sorted Set

### Cluster原理

### 内存淘汰策略

* volatile-lru
* allkeys-lru
* volatile-random
* allkeys-random
* volatile-ttl
* 

### 持久化方案

#### RDB

* 默认开启
* 基于快照，copy-on-write效率高
* 可能会丢失数据
* 配置方式时 n秒内写m次

#### AOF

* 需手动开启
* 以日志的形式记录服务器所处理的每一个写、删除操作
* 设置每秒刷新日志，最多丢失一秒数据
* 可用性高，效率低，需要空间大

## 分布式

### CAP理论

### Paxos算法

### Gossip

#### Cassandra

#### Redis Cluster

## 高可用

### 衡量标准

* 99% - 4天
* 99.9% - 10小时
* 99.99% - 1小时
* 99.999% - 6分钟

### 集群分类

#### 双机热备

#### 多节点热备

### keepalived原理

## 微服务

### 容错处理

#### 设置超时时间

#### 断路器模式

Hystrix

## 网络

### TCP协议

TCP 是一种面向连接的协议，它给用户进程提供可靠的全双工的字节流。确保数据包的可靠，有序，以及支持流量控制。

#### 特性

* 面向连接
* 可靠的全双工
* 有序
* 流量控制

#### 协议内容

##### 包组成

* 以太网Head、IP Head、TCP Head、Data
* 包默认大小536字节、最大不能超过MTU（1500字节）


##### 如何保证可靠性

* 三次握手，SEQ和ACK共同保证有序性
* 超时重传


#### 流量控制

* 批量发包
* 能够基于网络的状况，支持拥堵控制
* 能够了解接收端的状况，防止接收端处理不过来

##### 滑动窗口

##### 拥塞控制

* 慢启动
* 拥塞避免
* 快速重传
* 快恢复

#### TCP状态

##### 客户端

* 连接建立时
  SYN_SENT、ESTABLISHED
* 请求断开时
  FIN_WAIT1、FIN_WAIT2、TIME_WAIT

##### 服务端

* 连接建立时
  SYN_RCVD、ESTABLISHED
* 连接断开时
  CLOSE_WAIT、LAST_ACK

#### TIME_WAIT

保证非协议正常断开，连接可以关闭。
默认值为2*MSL

MSL是IP数据包能在网络中存活的最长时间。
